inverse <- x$getinverse()
## If the cached inverse of the matrix is not NULL, then do...
if(!is.null(inverse)){
## Output a message saying "getting cached data" and get the inverse from the cache
message("getting cached data")
return(inverse)
}
## If the cached inverse of the matrix is NULL, get the matrix
data <- x$get()
## calculate the inverse of the matrix
inverse <- solve(data, ...)
## Set the cached inverse of the matrix based on previous calculation
x$setinverse(inverse)
## Output the inverse of the matrix
inverse
}
z <- rbind(c(1,2,3,4,5))
z
z <- 1,2,3,4,5
z <- (1:5)
z
z <- (1:5)
z
makeVector <- function(z = numeric()) {
m <- NULL
set <- function(y) {
z <<- y
m <<- NULL
}
get <- function() z
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(z, ...) {
m <- z$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- z$get()
m <- mean(data, ...)
z$setmean(m)
m
}
m
getmean(z)
getmean(z,...)
z
mean(z)
makevector(z)
makeVector(z)
cachemean(z)
z <- (1:5)
z
makeVector <- function(b = numeric()) {
m <- NULL
set <- function(y) {
b <<- y
m <<- NULL
}
get <- function() b
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(b, ...) {
m <- b$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- b$get()
m <- mean(data, ...)
b$setmean(m)
m
}
makeVector(b)
cachemean(b)
append(b, 1:5)
b <- append(b, 1:5)
b <- c()
makeVector(b)
b <- append(b, 1:5)
cachemean(b)
makeCacheMatrix <- function(x = matrix()) {
##set the inverse of the matriz to NULL
inverse <- NULL
##
set <- function(y){
x <<- y
inverse <<- NULL
}
get <- function() x
setinverse <- function(solve) inverse <<- MatrixInverse
getinverse <- function() inverse
list(set=set, get=get, setinverse=setinverse, getinverse=getinverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
## Get the cached inverse of the matrix
inverse <- x$getinverse()
## If the cached inverse of the matrix is not NULL, then do...
if(!is.null(inverse)){
## Output a message saying "getting cached data" and get the inverse from the cache
message("getting cached data")
return(inverse)
}
## If the cached inverse of the matrix is NULL, get the matrix
data <- x$get()
## calculate the inverse of the matrix
inverse <- solve(data, ...)
## Set the cached inverse of the matrix based on previous calculation
x$setinverse(inverse)
## Output the inverse of the matrix
inverse
}
makeCacheMatrix(x)
cacheSolve(x)
a<-makeCacheMatrix()
a$set(matrix(1:4,2,2)
a$set(matrix(1:4,2,2))
a<-makeCacheMatrix()
a$set(matrix(1:4,2,2))
cacheSolve(a)
makeCacheMatrix <- function(x = matrix()) {
##set the inverse of the matriz to NULL
inverse <- NULL
##
set <- function(y){
x <<- y
inverse <<- NULL
}
get <- function() x
setinverse <- function(solve) inverse <<- solve
getinverse <- function() inverse
list(set=set, get=get, setinverse=setinverse, getinverse=getinverse)
}
a<-makeCacheMatrix()
a$set(matrix(1:4,2,2))
cacheSolve(a)
cacheSolve(a) %*% a
cacheSolve(a) %*% a
a
cacheSolve(a) %*% matrix(1:4,2,2)
a<-makeCacheMatrix()
a$set(matrix(5:8,2,2))
cacheSolve(a)
cacheSolve(a) %*% matrix(1:4,2,2)
cacheSolve(a) %*% matrix(5:8,2,2)
makeCacheMatrix <- function(x = matrix()) {
##set the inverse of the matriz to NULL
inverse <- NULL
##
set <- function(y){
x <<- y
inverse <<- NULL
}
get <- function() x
setinverse <- function(solve) inverse <<- solve
getinverse <- function() inverse
list(set=set, get=get, setinverse=setinverse, getinverse=getinverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
## Get the cached inverse of the matrix
inverse <- x$getinverse()
## If the cached inverse of the matrix is not NULL, then do...
if(!is.null(inverse)){
## Output a message saying "getting cached data" and get the inverse from the cache
message("getting cached data")
return(inverse)
}
## If the cached inverse of the matrix is NULL, get the matrix
data <- x$get()
## calculate the inverse of the matrix
inverse <- solve(data, ...)
## Set the cached inverse of the matrix based on previous calculation
x$setinverse(inverse)
## Output the inverse of the matrix
inverse
}
a<-makeCacheMatrix()
a$set(matrix(5:8,2,2))
cacheSolve(a)
cacheSolve(a) %*% matrix(5:8,2,2)
cacheSolve(a)
makeCacheMatrix <- function(x = matrix()) {
##set the inverse of the matriz to NULL
inverse <- NULL
set <- function(y){
x <<- y
inverse <<- NULL
}
## Get the value of the matrix
get <- function() x
## Set the value of the inverse of the matrix
setinverse <- function(solve) inverse <<- solve
## Get the value of the inverse of the matrix
getinverse <- function() inverse
list(set=set, get=get, setinverse=setinverse, getinverse=getinverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
## Get the cached inverse of the matrix
inverse <- x$getinverse()
## If the cached inverse of the matrix is not NULL, then do...
if(!is.null(inverse)){
## Output a message saying "getting cached data" and get the inverse from the cache
message("getting cached data")
return(inverse)
}
## If the cached inverse of the matrix is NULL, get the matrix
data <- x$get()
## calculate the inverse of the matrix
inverse <- solve(data, ...)
## Set the cached inverse of the matrix based on previous calculation
x$setinverse(inverse)
## Output the inverse of the matrix
inverse
}
a<-makeCacheMatrix()
a$set(matrix(5:8,2,2))
cacheSolve(a)
cacheSolve(a)
cacheSolve(a) %*% matrix(5:8,2,2)
a<-makeCacheMatrix()
a$set(matrix(1:9,3,3))
cacheSolve(a)
cacheSolve(a)
cacheSolve(a) %*% matrix(1:9,3,3)
b<-makeCacheMatrix()
b$set(matrix(1:9,3,3))
cacheSolve(b)
matrix(1:9,3,3)
b<-makeCacheMatrix()
b$set(matrix(1:16,4,4))
cacheSolve(b)
cacheSolve(b)
cacheSolve(b) %*% matrix(1:16,4,4)
b<-makeCacheMatrix()
b$set(matrix(1:4,2,2))
cacheSolve(b)
cacheSolve(b)
cacheSolve(b) %*% matrix(1:4,2,2)
makeCacheMatrix <- function(x = matrix()) {
##set the inverse of the matriz to NULL
inverse <- NULL
set <- function(y){
x <<- y
inverse <<- NULL
}
## Get the value of the matrix
get <- function() x
## Set the value of the inverse of the matrix
setinverse <- function(solve) inverse <<- solve
## Get the value of the inverse of the matrix
getinverse <- function() inverse
list(set=set, get=get, setinverse=setinverse, getinverse=getinverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
## Get the cached inverse of the matrix
inverse <- x$getinverse()
## If the cached inverse of the matrix is not NULL, then do...
if(!is.null(inverse)){
## Output a message saying "getting cached data" and get the inverse from the cache
message("getting cached data")
return(inverse)
}
## If the cached inverse of the matrix is NULL, get the matrix
data <- x$get()
## calculate the inverse of the matrix
inverse <- solve(data, ...)
## Set the cached inverse of the matrix based on previous calculation
x$setinverse(inverse)
## Output the inverse of the matrix
inverse
}
b<-makeCacheMatrix()
b$set(matrix(1:9,3,3))
cacheSolve(b)
## Create a matrix
makeCacheMatrix <- function(x = matrix()) {
##set the inverse of the matriz to NULL
inverse <- NULL
set <- function(y){
x <<- y
inverse <<- NULL
}
## Get the value of the matrix
get <- function() x
## Set the value of the inverse of the matrix
setinverse <- function(solve) inverse <<- solve
## Get the value of the inverse of the matrix
getinverse <- function() inverse
list(set=set, get=get, setinverse=setinverse, getinverse=getinverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
## Get the cached inverse of the matrix
inverse <- x$getinverse()
## If the cached inverse of the matrix is not NULL, then do...
if(!is.null(inverse)){
## Output a message saying "getting cached data" and get the inverse from the cache
message("getting cached data")
return(inverse)
}
## If the cached inverse of the matrix is NULL, get the matrix
data <- x$get()
## calculate the inverse of the matrix
inverse <- solve(data, ...)
## Set the cached inverse of the matrix based on previous calculation
x$setinverse(inverse)
## Output the inverse of the matrix
inverse
}
b<-makeCacheMatrix()
b$set(matrix(1:4,2,2))
cacheSolve(b)
cacheSolve(b)
cacheSolve(b) %*% matrix(1:4,2,2)
b<-makeCacheMatrix()
b$set(matrix(c(sample(6),sample(6),sample(6),sample(6),sample(6),sample(6)),6,6))
cacheSolve(b)
cacheSolve(b)
cacheSolve(b) %*% matrix(c(sample(6),sample(6),sample(6),sample(6),sample(6),sample(6)),6,6)
b<-makeCacheMatrix()
b$set(matrix(c(sample(6),sample(6),sample(6),sample(6),sample(6),sample(6)),6,6))
cacheSolve(b)
cacheSolve(b)
cacheSolve(b) %*% matrix(c(sample(6),sample(6),sample(6),sample(6),sample(6),sample(6)),6,6)
M<-matrix(c(sample(6),sample(6),sample(6),sample(6),sample(6),sample(6)),6,6)
cacheSolve(b) %*% M
M
M
> M<-matrix(c(sample(6),sample(6),sample(6),sample(6),sample(6),sample(6)),6,6)
> M<-matrix(c(sample(6),sample(6),sample(6),sample(6),sample(6),sample(6)),6,6)
matrix(c(sample(6),sample(6),sample(6),sample(6),sample(6),sample(6)),6,6)
matrix(c(sample(6),sample(6),sample(6),sample(6),sample(6),sample(6)),6,6)
b<-makeCacheMatrix()
b$set(matrix(c(7,0,-3,2,3,4,1,-1,-2), nrow=3, ncol=3))
cacheSolve(b)
cacheSolve(b)
cacheSolve(b) %*% matrix(c(7,0,-3,2,3,4,1,-1,-2), nrow=3, ncol=3)
Rprof()
set.seed(1)
rpois(5, 2)
set.seed(1)
rpois(5, 2)
set.seed(1)
rpois(5, 2)
set.seed(10)
rep(0:1, each = 5)
x <- rep(0:1, each = 5)
rnorm(10, 0, 20)
e <- rnorm(10, 0, 20)
y <- 0.5 + 2 * x + e
y
plot(x,y)
y <- c(1,2,3,4,5)
x1 <- c(9,8,7,6,5)
x2 <- c(4,5,6,7,8)
library(datasets)
Rprof()
fit <- lm(y ~ x1 + x2)
Rprof(NULL)
Rprof()
fit <- lm(y ~ x1 + x2)
summaryRprof()
source("http://d396qusza40orc.cloudfront.net/rprog%2Fscripts%2Fsubmitscript3.R")
setwd("C:/Users/eayres/Documents/Coursera_R-class/Quizses+Assignments/Programming Assignments/Programming3/")
submit()
source("http://d396qusza40orc.cloudfront.net/rprog%2Fscripts%2Fsubmitscript3.R")
setwd("C:/Users/eayres/Documents/Coursera_R-class/Quizses+Assignments/Programming Assignments/Programming3/")
submit()
source("http://d396qusza40orc.cloudfront.net/rprog%2Fscripts%2Fsubmitscript3.R")
setwd("C:/Users/eayres/Documents/Coursera_R-class/Quizses+Assignments/Programming Assignments/Programming3/")
submit()
rankall <- function(outcome, num = "best") {
x <- read.csv("outcome-of-care-measures.csv", colClasses = "character")
## Change heart attack, heart failure, and pneumonia columns to numeric
options(warn=-1)
x[, 11] <- as.numeric(x[, 11])
x[, 17] <- as.numeric(x[, 17])
x[, 23] <- as.numeric(x[, 23])
if(outcome == "heart attack"){k <- 11
} else if(outcome == "heart failure"){k <- 17
} else if(outcome == "pneumonia"){k <- 23
} else{stop("invalid outcome")}
a <- unique(unlist(x[,7]))
## Create dataframe
hospital <- c()
state <- c()
for(i in 1:54){
state <- append(state, c(a[i]))
y <- subset(x, x[,7]==a[i])
if(outcome == "heart attack"){
yOrder <- y[ order(y[,k],y[,2]), ]
if(num=="best"){
b <- 1
} else if(num=="worst"){
bad <- is.na(y[,k])
d <- max(y[,k][!bad])
b <- which(yOrder[,k]==d)
} else if(class(num)=="numeric"){
b <- num
}
hospital <- append(hospital, c(yOrder[b,2]))
} else if(outcome == "heart failure"){
yOrder <- y[ order(y[,k],y[,2]), ]
if(num=="best"){
b <- 1
} else if(num=="worst"){
bad <- is.na(y[,k])
d <- max(y[,k][!bad])
b <- which(y[,k]==d)
} else if(class(num)=="numeric"){
b <- num
}
hospital <- append(hospital, c(yOrder[b,2]))
} else if(outcome == "pneumonia"){
yOrder <- y[ order(y[,k],y[,2]), ]
if(num=="best"){
b <- 1
} else if(num=="worst"){
bad <- is.na(y[,k])
d <- max(y[,k][!bad])
b <- which(y[,k]==d)
} else if(class(num)=="numeric"){
b <- num
}
hospital <- append(hospital, c(yOrder[b,2]))
}
}
mydata <- data.frame(hospital, state)
mydataOrder <- mydata[ order(mydata[,2]), ]
mydataOrder
}
tail(rankall("pneumonia", "worst"), 3)
rankall("pneumonia", "worst"
)
setwd("C:/Users/eayres/Documents/Coursera_R-class/Quizses+Assignments/Programming Assignments/Programming3/")
num=="worst"
num = "best"
num=
"worst"
outcome =
"pneumonia"
x <- read.csv("outcome-of-care-measures.csv", colClasses = "character")
## Change heart attack, heart failure, and pneumonia columns to numeric
options(warn=-1)
x[, 11] <- as.numeric(x[, 11])
x[, 17] <- as.numeric(x[, 17])
x[, 23] <- as.numeric(x[, 23])
if(outcome == "heart attack"){k <- 11
} else if(outcome == "heart failure"){k <- 17
} else if(outcome == "pneumonia"){k <- 23
} else{stop("invalid outcome")}
a <- unique(unlist(x[,7]))
## Create dataframe
hospital <- c()
state <- c()
for(i in 1:54){
state <- append(state, c(a[i]))
y <- subset(x, x[,7]==a[i])
if(outcome == "heart attack"){
yOrder <- y[ order(y[,k],y[,2]), ]
if(num=="best"){
b <- 1
} else if(num=="worst"){
bad <- is.na(y[,k])
d <- max(y[,k][!bad])
b <- which(yOrder[,k]==d)
} else if(class(num)=="numeric"){
b <- num
}
hospital <- append(hospital, c(yOrder[b,2]))
} else if(outcome == "heart failure"){
yOrder <- y[ order(y[,k],y[,2]), ]
if(num=="best"){
b <- 1
} else if(num=="worst"){
bad <- is.na(y[,k])
d <- max(y[,k][!bad])
b <- which(y[,k]==d)
} else if(class(num)=="numeric"){
b <- num
}
hospital <- append(hospital, c(yOrder[b,2]))
} else if(outcome == "pneumonia"){
yOrder <- y[ order(y[,k],y[,2]), ]
if(num=="best"){
b <- 1
} else if(num=="worst"){
bad <- is.na(y[,k])
d <- max(y[,k][!bad])
b <- which(y[,k]==d)
} else if(class(num)=="numeric"){
b <- num
}
hospital <- append(hospital, c(yOrder[b,2]))
}
}
View(yOrder)
mydata <- data.frame(hospital, state)
hospital
state
